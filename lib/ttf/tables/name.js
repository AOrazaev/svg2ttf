'use strict';

// See documentation here: http://www.microsoft.com/typography/otspec/name.htm

var _ = require('lodash');
var jDataView = require('jDataView');

var TTF_NAMES = {
  COPYRIGHT: 0,
  FONT_FAMILY: 1,
  ID: 3,
  DESCRIPTION: 10,
  URL_VENDOR: 11
};

function tableSize(macNames, winNames) {
  var result = 6; // table header

  _.forEach(macNames, function (name) {
    result += 24 + name.data.length; //name header and data
  });

  _.forEach(winNames, function (name) {
    result += 24 + name.data.length; //name header and data
  });
  return result;
}

function getStringAsByteArray(str, twoByteFormat) {
  var bytes = [];
  for (var i = 0; i < str.length; i++) {
    var char = str.charCodeAt(i);
    if (twoByteFormat && (char < 256)) {
      bytes.push(0); //1-byte characters should be transformed to 2-bytes sequence to meet NAME table standards
    }
    bytes.push(char);
  }
  return bytes;
}

// Collect font names
function getNames(font, twoByteFormat) {
  var result = [];
  if (font.copyright) {
    result.push({ data: getStringAsByteArray(font.copyright, twoByteFormat), id: TTF_NAMES.COPYRIGHT});
  }
  if (font.familyName) {
    result.push({ data: getStringAsByteArray(font.familyName, twoByteFormat), id: TTF_NAMES.FONT_FAMILY});
  }
  if (font.id) {
    result.push({ data: getStringAsByteArray(font.id, twoByteFormat), id: TTF_NAMES.ID});
  }
  result.push({ data: getStringAsByteArray('Generated by svg2ttf from Fontello project.', twoByteFormat), id: TTF_NAMES.DESCRIPTION});
  result.push({ data: getStringAsByteArray('http://fontello.com', twoByteFormat), id: TTF_NAMES.URL_VENDOR});

  _.forEach(font.sfntNames, function (sfntName) {
    result.push({ data: getStringAsByteArray(sfntName.value, twoByteFormat), id: sfntName.id});
  });

  return result;
}

function writeNames(buf, names, platformID, encodingID, languageID, nameOffset) {
  nameOffset = nameOffset || 0;
  _.forEach(names, function (name) {
    buf.writeUint16(platformID); // platformID
    buf.writeUint16(encodingID); // platEncID
    buf.writeUint16(languageID); // languageID, English (USA)
    buf.writeUint16(name.id); // nameID
    buf.writeUint16(name.data.length); // reclength
    buf.writeUint16(nameOffset); // offset
    nameOffset += name.data.length;
  });
  return nameOffset;
}

function createNameTable(font) {

  var macNames = getNames(font, false);
  var winNames = getNames(font, true);

  var buf = new jDataView(tableSize(macNames, winNames));

  buf.writeUint16(0); // formatSelector
  buf.writeUint16(macNames.length + winNames.length); // nameRecordsCount, each name is written for windows and mac
  var offsetPosition = buf.tell();
  buf.writeUint16(0); // offset, will be filled later

  var nameOffset = 0;
  nameOffset += writeNames(buf, macNames, 1, 0, 0); // mac standard
  writeNames(buf, winNames, 3, 1, 0x409, nameOffset); // windows standard

  var actualStringDataOffset = buf.tell();

  //Array of bytes with actual string data
  _.forEach(macNames, function (name) {
    buf.writeBytes(name.data);
  });

  //Array of bytes with actual string data
  _.forEach(winNames, function (name) {
    buf.writeBytes(name.data);
  });

  //write actual string data offset
  buf.seek(offsetPosition);
  buf.writeUint16(actualStringDataOffset); // offset

  return buf;
}

module.exports = createNameTable;
